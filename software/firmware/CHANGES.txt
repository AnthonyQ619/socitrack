Changes I've made that this app should mirror:


I named the new protocol "noslots" in the other tree. I'm not attached
to that name, but as far as I can tell the existing protocol is in the
"dw1000" file, which sounds like a driver/library. The
protocol/application layer should be in reasonably named files that give
some indication of what protocol they implement.


Changed the message_type defines to:
(this is loosely using message types as a means of versioning)
#define MSG_TYPE_PP_NOSLOTS_TAG_POLL   0x80
#define MSG_TYPE_PP_NOSLOTS_ANC_FINAL  0x81


Changed the final response from anchor to tag to a "three try" system:
  * Tag listens sequentially on each channel for ALL_ANC_FINAL_US
  * Tag opportunistically bails early if all anchors are heard on first or second channel
  * Anchors check for ACK after sending final, trying all three channels if needed
  * Anchors return to idle once their final is ACK'd


To handle arbitrary anchors, the tag will only take measurements from
the first NUM_ANCHORS that it hears. Internally, it maps anchor ids
to slots in the table and the final reported packet adds ids.


The anchor data reporting protocol changed. Previously it was a space-
separated list of measurements with indexes corresponding to anchor
ids (e.g. 17:87.123). Spaces still separate measurements. The old no
packet from anchor code ("X") and insufficient measurements code ("-")
are dropped as they aren't useful.


The "tag poll" message structure changed to:
    struct pp_tag_poll  {
    	struct ieee154_header header;
    	uint8_t message_type;
    	uint8_t roundNum;
    	uint8_t subsequence;
    	uint8_t reply_after_subsequence;        //***** NEW
    	uint16_t anchor_reply_window_in_us;     //***** NEW
    	uint16_t anchor_reply_slot_time_in_us;  //***** NEW
    	struct ieee154_footer footer;
    } __attribute__ ((__packed__));
Where 'reply_after_subsequence' is a directive to the anchor to
reply after the given subsequence number (currently set to
NUM_MEASUREMENTS+NUM_RANGING_CHANNELS-1), anchor_reply_window_in_us
is the total window of time on each channel for anchor replies,
and anchor_reply_slot_time_in_us is the length of time slots for
anchor replies (e.g. anchors should xmit on a slot boundary).
This should hold:
_Static_assert(anchor_reply_window_in_us%anchor_reply_slot_time_in_us == 0)

